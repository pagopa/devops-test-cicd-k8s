# Azure DevOps pipeline to release a new version and deploy to production.

variables:
  NAMESPACE: "$(TF_NAMESPACE)"
  DOCKER_IMAGE_NAME: "$(TF_DOCKER_IMAGE_NAME)"
  CONTAINER_REGISTRY_FQDN_PROD: "$(TF_CONTAINER_REGISTRY_FQDN_PROD)"
  CONTAINER_REGISTRY_SERVICE_CONN_PROD: "$(TF_CONTAINER_REGISTRY_SERVICE_CONN_PROD)"
  KUBERNETES_SERVICE_CONN_WEU_BETA: "$(TF_KUBERNETES_SERVICE_CONN_WEU_BETA)"
  KUBERNETES_SERVICE_CONN_WEU_PROD_01: "$(TF_KUBERNETES_SERVICE_CONN_WEU_PROD_01)"
  KUBERNETES_SERVICE_CONN_WEU_PROD_02: "$(TF_KUBERNETES_SERVICE_CONN_WEU_PROD_02)"

parameters:
  - name: "RELEASE_SEMVER"
    displayName: "When packing a release, define the version bump to apply"
    type: string
    values:
      - major
      - minor
      - patch
    default: minor
  - name: "FORCE_REPLACE_DOCKER_IMAGE"
    displayName: "Force the existing docker image to be replaced"
    type: boolean
    default: False
    values:
      - False
      - True
  - name: "SKIP_RELEASE"
    displayName: "Skip release"
    type: boolean
    default: False
    values:
      - False
      - True
  - name: "ENVIRONMENT_WEU_BETA"
    displayName: "Deploy to weu-beta"
    type: boolean
    default: True
    values:
      - False
      - True
  - name: "ENVIRONMENT_WEU_PROD_01"
    displayName: "Deploy to weu-prod-01"
    type: boolean
    default: True
    values:
      - False
      - True
  - name: "ENVIRONMENT_WEU_PROD_02"
    displayName: "Deploy to weu-prod-02"
    type: boolean
    default: False
    values:
      - False
      - True

# Only manual activations are intended
trigger: none
pr: none

resources:
  repositories:
    - repository: pagopaCommons
      type: github
      name: pagopa/azure-pipeline-templates
      ref: add-deploy-release-decision
      endpoint: "azure-devops-github-ro-payments"

pool:
  vmImage: "ubuntu-latest"

stages:
  # Create a relase
  # Activated when ONE OF these are met:
  # - is on branch master
  # - is a tag in the form v{version}-RELEASE
  - stage: Release
    jobs:
      - job: make_release
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
        steps:
          - ${{ if eq(parameters['SKIP_RELEASE'], False) }}:
              - checkout: self
                displayName: "Checkout"
                persistCredentials: true
              - template: templates/maven-github-release/template.yaml@pagopaCommons
                parameters:
                  semver: "${{ parameters.RELEASE_SEMVER }}"
                  gitEmail: $(GIT_EMAIL)
                  gitUsername: $(GIT_USERNAME)
                  gitHubConnection: $(GITHUB_CONNECTION)
          - ${{ if eq(parameters['SKIP_RELEASE'], True) }}:
              - template: templates/maven-github-current-version/template.yaml@pagopaCommons
      - job: branch_version
        condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/master'))
        steps:
          - template: templates/maven-github-current-version/template.yaml@pagopaCommons
      # - job: deploy_release_decision
      #   dependsOn:
      #   - make_release
      #   - branch_version
      #   steps:
      #     - template: templates/deploy-release-decision/template.yaml@pagopaCommons
      #       parameters:
      #         next_version: $[ dependencies.make_release.outputs['next_version.value'] ]
      #         current_version: $[ dependencies.make_release.outputs['current_version.value'] ]
      #         current_version_branch: $[ dependencies.branch_version.outputs['current_version.value'] ]
      #         build_id: $(Build.BuildId)

  # Build
  - stage: Build
    dependsOn: Release
    variables:
      next_version: $[ stageDependencies.Release.make_release.outputs['next_version.value'] ]
      current_version: $[ stageDependencies.Release.make_release.outputs['current_version.value'] ]
      current_version_branch: $[ stageDependencies.Release.branch_version.outputs['current_version.value'] ]
    jobs:
      - job: "Build"
        steps:
          - template: templates/deploy-release-decision/template.yaml@pagopaCommons
            parameters:
              next_version: $(next_version)
              current_version: $(current_version)
              current_version_branch: $(current_version_branch)
              build_id: $(Build.BuildId)
          - task: Docker@2
            displayName: "docker login"
            inputs:
              containerRegistry: "$(CONTAINER_REGISTRY_SERVICE_CONN_PROD)"
              command: "login"
          - task: Bash@3
            displayName: "docker build and push (force)"
            condition: and(succeeded(), eq(${{ parameters.FORCE_REPLACE_DOCKER_IMAGE }}, True))
            inputs:
              targetType: "inline"
              script: |
                echo "[INFO] the parameter FORCE_REPLACE_DOCKER_IMAGE is set to true, start build and push"
                docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(Build.BuildId) .
                docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(next_version) .
                docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):latest .
                docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(Build.BuildId)
                docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(next_version)
                docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):latest
          - task: Bash@3
            displayName: "docker build and push"
            condition: and(succeeded(), eq(${{ parameters.FORCE_REPLACE_DOCKER_IMAGE }}, False))
            inputs:
              targetType: "inline"
              script: |
                # docker will return 0 on success or 1 on failure.
                docker manifest inspect $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(next_version) > /dev/null
                if [ $? -eq 0 ]; then
                  echo "[INFO] docker image already exists in the registry, skip build and push"
                else
                  echo "[INFO] docker image does not exist in the registry, start build and push"
                  docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(Build.BuildId) .
                  docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(next_version) .
                  docker build -t $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):latest .
                  docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(Build.BuildId)
                  docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):$(next_version)
                  docker push $(CONTAINER_REGISTRY_FQDN_PROD)/$(DOCKER_IMAGE_NAME):latest
                fi

  # - stage: 'Serving_helm'
  #   displayName: 'Serving_Helm'
  #   dependsOn: Build
  #   jobs:
  #     - job: Serving_helm
  #       displayName: Serving_helm
  #       steps:
  #         - task: PublishPipelineArtifact@1
  #           displayName: 'Publish Artifact manifests'
  #           condition: succeeded()
  #           inputs:
  #             targetPath: '$(Build.Repository.LocalPath)/helm'
  #             artifact: 'helm'
  #             publishLocation: 'pipeline'

  # - stage: 'Deploy'
  #   dependsOn: 'Serving_helm'
  #   jobs:
  #     - deployment: 'Deploy'
  #       pool:
  #         name: io-prod-linux
  #       environment: PROD
  #       strategy:
  #         runOnce:
  #           deploy:
  #             steps:
  #               - download: none
  #               - task: DownloadPipelineArtifact@2
  #                 inputs:
  #                   buildType: 'current'
  #                   artifactName: 'helm'
  #                   targetPath: '$(Pipeline.Workspace)/helm'
  #               - task: Bash@3
  #                 displayName: 'prepare helm'
  #                 inputs:
  #                   targetType: 'inline'
  #                   script: |
  #                     helm repo add microservice-chart https://pagopa.github.io/aks-microservice-chart-blueprint
  #                     helm dep build $(Pipeline.Workspace)/helm
  #               - task: HelmDeploy@0
  #                 displayName: Helm upgrade
  #                 condition: and(succeeded(), eq(${{ parameters.ENVIRONMENT_WEU_BETA }}, True))
  #                 inputs:
  #                   kubernetesServiceEndpoint: $(KUBERNETES_SERVICE_CONN_WEU_BETA)
  #                   namespace: $(NAMESPACE)
  #                   command: upgrade
  #                   chartType: filepath
  #                   chartPath: $(Pipeline.Workspace)/helm
  #                   chartName: $(DOCKER_IMAGE_NAME)
  #                   releaseName: $(DOCKER_IMAGE_NAME)
  #                   valueFile: '$(Pipeline.Workspace)/helm/values-beta.yaml'
  #                   install: true
  #                   waitForExecution: true
  #                   arguments: '--timeout 5m0s'
  #                   overrideValues: microservice-chart.image.tag=$(Build.BuildId)
  #               - task: HelmDeploy@0
  #                 displayName: Helm upgrade
  #                 condition: and(succeeded(), eq(${{ parameters.ENVIRONMENT_WEU_PROD_01 }}, True))
  #                 inputs:
  #                   kubernetesServiceEndpoint: $(KUBERNETES_SERVICE_CONN_WEU_PROD_01)
  #                   namespace: $(NAMESPACE)
  #                   command: upgrade
  #                   chartType: filepath
  #                   chartPath: $(Pipeline.Workspace)/helm
  #                   chartName: $(DOCKER_IMAGE_NAME)
  #                   releaseName: $(DOCKER_IMAGE_NAME)
  #                   valueFile: '$(Pipeline.Workspace)/helm/values-prod01.yaml'
  #                   install: true
  #                   waitForExecution: true
  #                   arguments: '--timeout 5m0s'
  #                   overrideValues: microservice-chart.image.tag=$(Build.BuildId)
  #               - task: HelmDeploy@0
  #                 displayName: Helm upgrade
  #                 condition: and(succeeded(), eq(${{ parameters.ENVIRONMENT_WEU_PROD_02 }}, True))
  #                 inputs:
  #                   kubernetesServiceEndpoint: $(KUBERNETES_SERVICE_CONN_WEU_PROD_02)
  #                   namespace: $(NAMESPACE)
  #                   command: upgrade
  #                   chartType: filepath
  #                   chartPath: $(Pipeline.Workspace)/helm
  #                   chartName: $(DOCKER_IMAGE_NAME)
  #                   releaseName: $(DOCKER_IMAGE_NAME)
  #                   valueFile: '$(Pipeline.Workspace)/helm/values-prod02.yaml'
  #                   install: true
  #                   waitForExecution: true
  #                   arguments: '--timeout 5m0s'
  #                   overrideValues: microservice-chart.image.tag=$(Build.BuildId)
